<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · QXTn.jl</title><link rel="canonical" href="https://JuliaQX.github.io/QXTn.jl/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href><img src="assets/logo.svg" alt="QXTn.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">QXTn.jl</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#Installation"><span>Installation</span></a></li><li><a class="tocitem" href="#Example-usage"><span>Example usage</span></a></li><li><a class="tocitem" href="#Contributing"><span>Contributing</span></a></li><li><a class="tocitem" href="#Building-documentation"><span>Building documentation</span></a></li><li><a class="tocitem" href="#API-Reference"><span>API Reference</span></a></li></ul></li><li><a class="tocitem" href="data_structures/">Data Structures</a></li><li><a class="tocitem" href="license/">LICENSE</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaQX/QXTn.jl/blob/master/docs/src/index.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="QXTn"><a class="docs-heading-anchor" href="#QXTn">QXTn</a><a id="QXTn-1"></a><a class="docs-heading-anchor-permalink" href="#QXTn" title="Permalink"></a></h1><p>QXTn is a Julia package with data structures and utilities for manipulating tensor networks. As well as generic tensor network data structure, it also contains specific data structures for handling tensor networks derived from quantum circuits. It was developed as part of the QuantEx project, one of the individual software projects of WP8 of PRACE 6IP.</p><p>It uses some features from <a href="https://github.com/ITensor/ITensors.jl">ITensors</a> and <a href="https://github.com/ITensor/NDTensors.jl">NDTensors</a> for representing tensors and indices and performing contractions.</p><h2 id="Installation"><a class="docs-heading-anchor" href="#Installation">Installation</a><a id="Installation-1"></a><a class="docs-heading-anchor-permalink" href="#Installation" title="Permalink"></a></h2><p>QXTn is a Julia package and can be installed using Julia&#39;s inbuilt package manager from the Julia REPL using.</p><pre><code class="language-none">import Pkg
Pkg.add(&quot;QXTn&quot;)</code></pre><p>To ensure everything is working, the unittests can be run using</p><pre><code class="language-none">import Pkg; Pkg.test()</code></pre><h2 id="Example-usage"><a class="docs-heading-anchor" href="#Example-usage">Example usage</a><a id="Example-usage-1"></a><a class="docs-heading-anchor-permalink" href="#Example-usage" title="Permalink"></a></h2><p>An example of creating a simple tensor network and contracting.</p><pre><code class="language-none">using QXTn

tn = TensorNetwork()

a, b, c, d = Index(2), Index(3), Index(5), Index(4)

# add a 2x3x5 rank tensor
push!(tn, [a, b, c], rand(2, 3, 5))
# add a 5x4 matrix
push!(tn, [c, d], rand(5, 4))

# contract network
simple_contraction!(tn)

# number of tensors after contraction
@show length(tn)

# resulting tensor has dimensions should have dimensions 2x3x4
@show size(first(tn))</code></pre><h2 id="Contributing"><a class="docs-heading-anchor" href="#Contributing">Contributing</a><a id="Contributing-1"></a><a class="docs-heading-anchor-permalink" href="#Contributing" title="Permalink"></a></h2><p>Contributions from users are welcome and we encourage users to open issues and submit merge/pull requests for any problems or feature requests they have. The CONTRIBUTING.md on the top level of the source folder has further details of the contribution guidelines.</p><h2 id="Building-documentation"><a class="docs-heading-anchor" href="#Building-documentation">Building documentation</a><a id="Building-documentation-1"></a><a class="docs-heading-anchor-permalink" href="#Building-documentation" title="Permalink"></a></h2><p>QXTn.jl uses <a href="https://juliadocs.github.io/Documenter.jl/stable/">Documenter.jl</a> to generate documentation. To build the documentation locally run the following from the root folder.</p><p>The first time it is will be necessary to instantiate the environment to install dependencies</p><pre><code class="language-none">julia --project=docs/ -e &#39;using Pkg; Pkg.develop(PackageSpec(path=pwd())); Pkg.instantiate()&#39;</code></pre><p>and then to build the documentation</p><pre><code class="language-none">julia --project=docs/ docs/make.jl</code></pre><p>The generated document will be in the <code>docs/build</code> folder. To serve these locally one can use the LiveServer package as</p><pre><code class="language-none">julia --project -e &#39;import Pkg; Pkg.add(&quot;LiveServer&quot;);
julia --project -e  &#39;using LiveServer; serve(dir=&quot;docs/build&quot;)&#39;</code></pre><p>Or with python3 using from the <code>docs/build</code> folder using</p><pre><code class="language-none">python3 -m http.server</code></pre><p>The generated documentation should now be viewable locally in a browser at <code>http://localhost:8000</code>.</p><h2 id="API-Reference"><a class="docs-heading-anchor" href="#API-Reference">API Reference</a><a id="API-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#API-Reference" title="Permalink"></a></h2><ul><li><a href="#QXTn.MockTensor"><code>QXTn.MockTensor</code></a></li><li><a href="#QXTn.QXTensor"><code>QXTn.QXTensor</code></a></li><li><a href="data_structures/#QXTn.QXTensor"><code>QXTn.QXTensor</code></a></li><li><a href="#QXTn.QXTensor-Tuple{Vector{var&quot;#s16&quot;} where var&quot;#s16&quot;&lt;:Index}"><code>QXTn.QXTensor</code></a></li><li><a href="#QXTn.QXTensor-Union{Tuple{N}, Tuple{Elt}, Tuple{AbstractArray{Elt, N}, Vector{var&quot;#s11&quot;} where var&quot;#s11&quot;&lt;:Index}} where {Elt, N}"><code>QXTn.QXTensor</code></a></li><li><a href="#QXTn.QXTensor-Tuple{T} where T&lt;:Number"><code>QXTn.QXTensor</code></a></li><li><a href="#QXTn.TensorNetwork-Tuple{Vector{var&quot;#s22&quot;} where var&quot;#s22&quot;&lt;:QXTensor}"><code>QXTn.TensorNetwork</code></a></li><li><a href="data_structures/#QXTn.TensorNetwork"><code>QXTn.TensorNetwork</code></a></li><li><a href="data_structures/#QXTn.TensorNetworkCircuit"><code>QXTn.TensorNetworkCircuit</code></a></li><li><a href="#Base.convert-Union{Tuple{N}, Tuple{Type{QXTensor}, ITensors.ITensor{N}}} where N"><code>Base.convert</code></a></li><li><a href="#Base.convert-Tuple{Type{ITensors.ITensor}, QXTensor}"><code>Base.convert</code></a></li><li><a href="#Base.copy-Tuple{MockTensor}"><code>Base.copy</code></a></li><li><a href="#Base.delete!-Tuple{TensorNetworkCircuit, Symbol}"><code>Base.delete!</code></a></li><li><a href="#Base.delete!-Tuple{TensorNetwork, Symbol}"><code>Base.delete!</code></a></li><li><a href="#Base.merge-Tuple{TensorNetwork, TensorNetwork}"><code>Base.merge</code></a></li><li><a href="#Base.push!-Union{Tuple{T}, Tuple{TensorNetworkCircuit, Vector{Int64}, Matrix{T}}} where T"><code>Base.push!</code></a></li><li><a href="#Base.push!-Union{Tuple{N}, Tuple{TensorNetwork, QXTensor}} where N"><code>Base.push!</code></a></li><li><a href="#Base.push!-Union{Tuple{N}, Tuple{T}, Tuple{TensorNetwork, Vector{var&quot;#s21&quot;} where var&quot;#s21&quot;&lt;:Index, Array{T, N}}} where {T, N}"><code>Base.push!</code></a></li><li><a href="#Base.show-Tuple{IO, MIME{Symbol(&quot;text/plain&quot;)}, QXTensor}"><code>Base.show</code></a></li><li><a href="#Base.size-Tuple{QXTensor}"><code>Base.size</code></a></li><li><a href="#NDTensors.inds-Tuple{QXTensor}"><code>NDTensors.inds</code></a></li><li><a href="#NDTensors.store-Tuple{QXTensor}"><code>NDTensors.store</code></a></li><li><a href="#QXTn._contract_ncon_indices-Union{Tuple{N}, Tuple{M}, Tuple{ITensors.IndexSet{M, IndexT, DataT} where {IndexT&lt;:Index, DataT&lt;:Tuple}, ITensors.IndexSet{N, IndexT, DataT} where {IndexT&lt;:Index, DataT&lt;:Tuple}}} where {M, N}"><code>QXTn._contract_ncon_indices</code></a></li><li><a href="#QXTn.add_input!"><code>QXTn.add_input!</code></a></li><li><a href="#QXTn.add_output!"><code>QXTn.add_output!</code></a></li><li><a href="#QXTn.contract_hyper_indices-Tuple{Vector{var&quot;#s21&quot;} where var&quot;#s21&quot;&lt;:Index, Vector{var&quot;#s22&quot;} where var&quot;#s22&quot;&lt;:(Vector{var&quot;#s23&quot;} where var&quot;#s23&quot;&lt;:Index), Vector{var&quot;#s24&quot;} where var&quot;#s24&quot;&lt;:Index, Vector{var&quot;#s25&quot;} where var&quot;#s25&quot;&lt;:(Vector{var&quot;#s26&quot;} where var&quot;#s26&quot;&lt;:Index)}"><code>QXTn.contract_hyper_indices</code></a></li><li><a href="#QXTn.contract_ncon_indices-Tuple{TensorNetwork, Symbol, Symbol}"><code>QXTn.contract_ncon_indices</code></a></li><li><a href="#QXTn.contract_pair!"><code>QXTn.contract_pair!</code></a></li><li><a href="#QXTn.contract_tensors-Tuple{QXTensor, QXTensor}"><code>QXTn.contract_tensors</code></a></li><li><a href="#QXTn.contract_tn!-Tuple{TensorNetwork, Vector{Tuple{Symbol, Symbol, Symbol}}}"><code>QXTn.contract_tn!</code></a></li><li><a href="#QXTn.create_test_tnc-Tuple{}"><code>QXTn.create_test_tnc</code></a></li><li><a href="#QXTn.decompose_gate"><code>QXTn.decompose_gate</code></a></li><li><a href="#QXTn.decompose_tensor!-Tuple{TensorNetwork, Symbol, Vector{var&quot;#s21&quot;} where var&quot;#s21&quot;&lt;:Index}"><code>QXTn.decompose_tensor!</code></a></li><li><a href="#QXTn.find_hyper_edges-Union{Tuple{AbstractArray{Elt, N}}, Tuple{N}, Tuple{Elt}} where {Elt, N}"><code>QXTn.find_hyper_edges</code></a></li><li><a href="#QXTn.get_hyperedges-Tuple{TensorNetwork}"><code>QXTn.get_hyperedges</code></a></li><li><a href="#QXTn.hyperindices-Tuple{QXTensor}"><code>QXTn.hyperindices</code></a></li><li><a href="#QXTn.isdiagonal-Union{Tuple{AbstractMatrix{Elt}}, Tuple{Elt}} where Elt"><code>QXTn.isdiagonal</code></a></li><li><a href="#QXTn.isdiagonal-Union{Tuple{N}, Tuple{Elt}, Tuple{AbstractArray{Elt, N}, Pair{Int64, Int64}}} where {Elt, N}"><code>QXTn.isdiagonal</code></a></li><li><a href="#QXTn.mock_contract"><code>QXTn.mock_contract</code></a></li><li><a href="#QXTn.neighbours-Tuple{TensorNetwork, Symbol}"><code>QXTn.neighbours</code></a></li><li><a href="#QXTn.push_input!-Union{Tuple{Elt}, Tuple{TensorNetworkCircuit, Vector{Elt}, Int64}} where Elt"><code>QXTn.push_input!</code></a></li><li><a href="#QXTn.push_output!-Union{Tuple{Elt}, Tuple{TensorNetworkCircuit, Vector{Elt}, Int64}} where Elt"><code>QXTn.push_output!</code></a></li><li><a href="#QXTn.reduce_tensor-Union{Tuple{N}, Tuple{Elt}, Tuple{AbstractArray{Elt, N}, Vector{Vector{Int64}}}} where {Elt, N}"><code>QXTn.reduce_tensor</code></a></li><li><a href="#QXTn.replace_tensor_symbol!-Tuple{TensorNetwork, Symbol, Symbol}"><code>QXTn.replace_tensor_symbol!</code></a></li><li><a href="#QXTn.replace_with_svd!-Tuple{TensorNetwork, Symbol, Vector{var&quot;#s21&quot;} where var&quot;#s21&quot;&lt;:Index}"><code>QXTn.replace_with_svd!</code></a></li><li><a href="#QXTn.simple_contraction-Tuple{TensorNetwork}"><code>QXTn.simple_contraction</code></a></li><li><a href="#QXTn.simple_contraction!-Tuple{TensorNetwork}"><code>QXTn.simple_contraction!</code></a></li><li><a href="#QXTn.tensor_data-Tuple{QXTensor}"><code>QXTn.tensor_data</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="QXTn.MockTensor" href="#QXTn.MockTensor"><code>QXTn.MockTensor</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Tensor store struct that just tracks tensor dimensions</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQX/QXTn.jl/blob/b421f835400f65583753677d91a33ea7c2e6bb35/src/mock_tensor.jl#LL14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QXTn.QXTensor" href="#QXTn.QXTensor"><code>QXTn.QXTensor</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">QXTensor(indices::Array{&lt;:Index, 1},
         hyper_indices::Array{&lt;:Array{Int64, 1}, 1},
         storage::Union{Nothing, &lt;: NDTensors.TensorStorage}=nothing)</code></pre><p>QXTensor constructor which creates a new instance of QXTensor with the given indices and hyper indices. If no storage data structure is given then MockTensor of that shape is added as the storage.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQX/QXTn.jl/blob/b421f835400f65583753677d91a33ea7c2e6bb35/src/tensor.jl#LL38-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QXTn.QXTensor-Tuple{T} where T&lt;:Number" href="#QXTn.QXTensor-Tuple{T} where T&lt;:Number"><code>QXTn.QXTensor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">QXTensor(a::T) where T &lt;: Number</code></pre><p>QXTensor constructor which creates a new instance of QXTensor corresponding to a scalar</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQX/QXTn.jl/blob/b421f835400f65583753677d91a33ea7c2e6bb35/src/tensor.jl#LL28-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QXTn.QXTensor-Tuple{Vector{var&quot;#s16&quot;} where var&quot;#s16&quot;&lt;:Index}" href="#QXTn.QXTensor-Tuple{Vector{var&quot;#s16&quot;} where var&quot;#s16&quot;&lt;:Index}"><code>QXTn.QXTensor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">QXTensor(indices::Array{&lt;:Index, 1})</code></pre><p>QXTensor constructor to create an instance of QXTensor with the given indices and will use MockTensor for the data storage.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQX/QXTn.jl/blob/b421f835400f65583753677d91a33ea7c2e6bb35/src/tensor.jl#LL56-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QXTn.QXTensor-Union{Tuple{N}, Tuple{Elt}, Tuple{AbstractArray{Elt, N}, Vector{var&quot;#s11&quot;} where var&quot;#s11&quot;&lt;:Index}} where {Elt, N}" href="#QXTn.QXTensor-Union{Tuple{N}, Tuple{Elt}, Tuple{AbstractArray{Elt, N}, Vector{var&quot;#s11&quot;} where var&quot;#s11&quot;&lt;:Index}} where {Elt, N}"><code>QXTn.QXTensor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">QXTensor(data::AbstractArray{Elt, N},
         indices::Array{&lt;:Index, 1};
         diagonal_check::Bool=true) where {Elt, N}</code></pre><p>Constructor to create a QXTensor instance using the given data and indices. If diagonal<em>check is true, it will automaticallly check which indices are hyper indices and record in the hyper</em>indices field.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQX/QXTn.jl/blob/b421f835400f65583753677d91a33ea7c2e6bb35/src/tensor.jl#LL66-L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QXTn.TensorNetwork-Tuple{Vector{var&quot;#s22&quot;} where var&quot;#s22&quot;&lt;:QXTensor}" href="#QXTn.TensorNetwork-Tuple{Vector{var&quot;#s22&quot;} where var&quot;#s22&quot;&lt;:QXTensor}"><code>QXTn.TensorNetwork</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">TensorNetwork(array::Vector{&lt;: QXTensor})</code></pre><p>Outer constructor to create a tensor network object from an array of ITensor objects.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQX/QXTn.jl/blob/b421f835400f65583753677d91a33ea7c2e6bb35/src/tensor_network.jl#LL44-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.convert-Tuple{Type{ITensors.ITensor}, QXTensor}" href="#Base.convert-Tuple{Type{ITensors.ITensor}, QXTensor}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.convert(::Type{ITensor}, t::QXTensor)</code></pre><p>Overloaded convert to enable conversion of a QXTensor to an ITensor. Note that doing this will mean that information about the hyper indices will be lost.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQX/QXTn.jl/blob/b421f835400f65583753677d91a33ea7c2e6bb35/src/tensor.jl#LL95-L100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.convert-Union{Tuple{N}, Tuple{Type{QXTensor}, ITensors.ITensor{N}}} where N" href="#Base.convert-Union{Tuple{N}, Tuple{Type{QXTensor}, ITensors.ITensor{N}}} where N"><code>Base.convert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.convert(::Type{QXTensor}, t::ITensor{N}) where N</code></pre><p>Overloaded convert to enable conversion of an ITensor to a QXTensor. Note that converting in this way means that hyper indices won&#39;t be identified.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQX/QXTn.jl/blob/b421f835400f65583753677d91a33ea7c2e6bb35/src/tensor.jl#LL105-L110">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.copy-Tuple{MockTensor}" href="#Base.copy-Tuple{MockTensor}"><code>Base.copy</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Overload functions from base to make MockTensor usable</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQX/QXTn.jl/blob/b421f835400f65583753677d91a33ea7c2e6bb35/src/mock_tensor.jl#LL21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.delete!-Tuple{TensorNetwork, Symbol}" href="#Base.delete!-Tuple{TensorNetwork, Symbol}"><code>Base.delete!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">delete!(tn::TensorNetwork, tensor_id::Symbol)</code></pre><p>Function to remove a tensor from a tensor network.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQX/QXTn.jl/blob/b421f835400f65583753677d91a33ea7c2e6bb35/src/tensor_network.jl#LL311-L315">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.delete!-Tuple{TensorNetworkCircuit, Symbol}" href="#Base.delete!-Tuple{TensorNetworkCircuit, Symbol}"><code>Base.delete!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">delete!(tnc::TensorNetworkCircuit, tensor_id::Symbol)</code></pre><p>Function to remove a tensor from a tensor network circuit.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQX/QXTn.jl/blob/b421f835400f65583753677d91a33ea7c2e6bb35/src/tensor_network_circuit.jl#LL113-L117">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.merge-Tuple{TensorNetwork, TensorNetwork}" href="#Base.merge-Tuple{TensorNetwork, TensorNetwork}"><code>Base.merge</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">merge(a::TensorNetwork, b::TensorNetwork)</code></pre><p>Join two networks together</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQX/QXTn.jl/blob/b421f835400f65583753677d91a33ea7c2e6bb35/src/tensor_network.jl#LL96-L100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.push!-Union{Tuple{N}, Tuple{TensorNetwork, QXTensor}} where N" href="#Base.push!-Union{Tuple{N}, Tuple{TensorNetwork, QXTensor}} where N"><code>Base.push!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">push!(tn::TensorNetwork,
      tensor::QXTensor;
      tid::Union{Nothing, Symbol}=nothing) where {N}</code></pre><p>Function to add a tensor to the tensor network.</p><p><strong>Keywords</strong></p><ul><li><code>tid::Union{Nothing, Symbol}=nothing</code>: the id for the new tensor in <code>tn</code>. An id is </li></ul><p>generated if one is not set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQX/QXTn.jl/blob/b421f835400f65583753677d91a33ea7c2e6bb35/src/tensor_network.jl#LL140-L150">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.push!-Union{Tuple{N}, Tuple{T}, Tuple{TensorNetwork, Vector{var&quot;#s21&quot;} where var&quot;#s21&quot;&lt;:Index, Array{T, N}}} where {T, N}" href="#Base.push!-Union{Tuple{N}, Tuple{T}, Tuple{TensorNetwork, Vector{var&quot;#s21&quot;} where var&quot;#s21&quot;&lt;:Index, Array{T, N}}} where {T, N}"><code>Base.push!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">push!(tn::TensorNetwork,
      indices::Vector{Index},
      data::Array{T, N}
      tid::Union{Nothing, Symbol}=nothing) where {T, N}</code></pre><p>Function to add a tensor to the tensor network.</p><p><strong>Keywords</strong></p><ul><li><code>tid::Union{Nothing, Symbol}=nothing</code>: the id for the new tensor in <code>tn</code>. An id is </li></ul><p>generated if one is not set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQX/QXTn.jl/blob/b421f835400f65583753677d91a33ea7c2e6bb35/src/tensor_network.jl#LL109-L120">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.push!-Union{Tuple{T}, Tuple{TensorNetworkCircuit, Vector{Int64}, Matrix{T}}} where T" href="#Base.push!-Union{Tuple{T}, Tuple{TensorNetworkCircuit, Vector{Int64}, Matrix{T}}} where T"><code>Base.push!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">push!(tnc::TensorNetworkCircuit,
      qubits::Vector{Int64},
      data::Array{T, 2}) where T</code></pre><p>Function to add a gate to the tensor network circuit given the qubits it acts on and an array of the matrix elements</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQX/QXTn.jl/blob/b421f835400f65583753677d91a33ea7c2e6bb35/src/tensor_network_circuit.jl#LL71-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.show-Tuple{IO, MIME{Symbol(&quot;text/plain&quot;)}, QXTensor}" href="#Base.show-Tuple{IO, MIME{Symbol(&quot;text/plain&quot;)}, QXTensor}"><code>Base.show</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Custom show for QXTensors</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQX/QXTn.jl/blob/b421f835400f65583753677d91a33ea7c2e6bb35/src/tensor.jl#LL19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.size-Tuple{QXTensor}" href="#Base.size-Tuple{QXTensor}"><code>Base.size</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Custom size function</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQX/QXTn.jl/blob/b421f835400f65583753677d91a33ea7c2e6bb35/src/tensor.jl#LL21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NDTensors.inds-Tuple{QXTensor}" href="#NDTensors.inds-Tuple{QXTensor}"><code>NDTensors.inds</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Implement inds for QXTensor</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQX/QXTn.jl/blob/b421f835400f65583753677d91a33ea7c2e6bb35/src/tensor.jl#LL23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NDTensors.store-Tuple{QXTensor}" href="#NDTensors.store-Tuple{QXTensor}"><code>NDTensors.store</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Implement store for QXTensor</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQX/QXTn.jl/blob/b421f835400f65583753677d91a33ea7c2e6bb35/src/tensor.jl#LL25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QXTn._contract_ncon_indices-Union{Tuple{N}, Tuple{M}, Tuple{ITensors.IndexSet{M, IndexT, DataT} where {IndexT&lt;:Index, DataT&lt;:Tuple}, ITensors.IndexSet{N, IndexT, DataT} where {IndexT&lt;:Index, DataT&lt;:Tuple}}} where {M, N}" href="#QXTn._contract_ncon_indices-Union{Tuple{N}, Tuple{M}, Tuple{ITensors.IndexSet{M, IndexT, DataT} where {IndexT&lt;:Index, DataT&lt;:Tuple}, ITensors.IndexSet{N, IndexT, DataT} where {IndexT&lt;:Index, DataT&lt;:Tuple}}} where {M, N}"><code>QXTn._contract_ncon_indices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">_contract_ncon_indices(A_inds::IndexSet{M}, B_inds::IndexSet{N}) where {M, N}</code></pre><p>Function return indices in ncon format for contraction of tensors with given index sets. Returns two tuples for indices in each with convention that negative values are remaining indices and positive values are indices being contracted over.</p><p>For example if (1, -1), (-2, 1) is returned, this menas that the first index of tensor A A is contracted with the second index of  tensor B and the resulting tensor will have indices corresponding to the second index of the first tensor and first index of the second tensor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQX/QXTn.jl/blob/b421f835400f65583753677d91a33ea7c2e6bb35/src/tensor_network.jl#LL341-L352">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QXTn.add_input!" href="#QXTn.add_input!"><code>QXTn.add_input!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">add_input!(tnc::TensorNetworkCircuit; input::Union{String, Nothing}=nothing)</code></pre><p>Function to add input tensors to the circuit</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQX/QXTn.jl/blob/b421f835400f65583753677d91a33ea7c2e6bb35/src/tensor_network_circuit.jl#LL152-L156">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QXTn.add_output!" href="#QXTn.add_output!"><code>QXTn.add_output!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">add_output!(tnc::TensorNetworkCircuit; output::Union{String, Nothing}=nothing)</code></pre><p>Function to add output tensors to the circuit</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQX/QXTn.jl/blob/b421f835400f65583753677d91a33ea7c2e6bb35/src/tensor_network_circuit.jl#LL162-L166">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QXTn.contract_hyper_indices-Tuple{Vector{var&quot;#s21&quot;} where var&quot;#s21&quot;&lt;:Index, Vector{var&quot;#s22&quot;} where var&quot;#s22&quot;&lt;:(Vector{var&quot;#s23&quot;} where var&quot;#s23&quot;&lt;:Index), Vector{var&quot;#s24&quot;} where var&quot;#s24&quot;&lt;:Index, Vector{var&quot;#s25&quot;} where var&quot;#s25&quot;&lt;:(Vector{var&quot;#s26&quot;} where var&quot;#s26&quot;&lt;:Index)}" href="#QXTn.contract_hyper_indices-Tuple{Vector{var&quot;#s21&quot;} where var&quot;#s21&quot;&lt;:Index, Vector{var&quot;#s22&quot;} where var&quot;#s22&quot;&lt;:(Vector{var&quot;#s23&quot;} where var&quot;#s23&quot;&lt;:Index), Vector{var&quot;#s24&quot;} where var&quot;#s24&quot;&lt;:Index, Vector{var&quot;#s25&quot;} where var&quot;#s25&quot;&lt;:(Vector{var&quot;#s26&quot;} where var&quot;#s26&quot;&lt;:Index)}"><code>QXTn.contract_hyper_indices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">contract_hyper_indices(a_indices::Array{&lt;:Index, 1},
                       a_hyper_indices::Array{&lt;:Array{&lt;:Index, 1}, 1},
                       b_indices::Array{&lt;:Index, 1},
                       b_hyper_indices::Array{&lt;:Array{&lt;:Index, 1}, 1})</code></pre><p>This function calculates the resulting groups of hyper indices after contracting tensors with the given groups of hyper indices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQX/QXTn.jl/blob/b421f835400f65583753677d91a33ea7c2e6bb35/src/tensor.jl#LL153-L161">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QXTn.contract_ncon_indices-Tuple{TensorNetwork, Symbol, Symbol}" href="#QXTn.contract_ncon_indices-Tuple{TensorNetwork, Symbol, Symbol}"><code>QXTn.contract_ncon_indices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">contract_ncon_indices(tn::TensorNetwork, A_sym::Symbol, B_sym)</code></pre><p>Function return indices in ncon format for contraction of tensors with given symbols. Returns two tuples for indices in each with convention that negative values are remaining indices and positive values are indices being contracted over.</p><p>For example if (1, -1), (-2, 1) is returned, this menas that the first index of tensor A A is contracted with the second index of  tensor B and the resulting tensor will have indices corresponding to the second index of the first tensor and first index of the second tensor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQX/QXTn.jl/blob/b421f835400f65583753677d91a33ea7c2e6bb35/src/tensor_network.jl#LL325-L336">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QXTn.contract_pair!" href="#QXTn.contract_pair!"><code>QXTn.contract_pair!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">contract_pair!(tn::TensorNetwork, A_id::Symbol, B_id::Symbol; mock::Bool=false)</code></pre><p>Contract the tensors in &#39;tn&#39; with ids &#39;A<em>id&#39; and &#39;B</em>id&#39;. If the mock flag is true then the new tensor will be a mock tensor with the right dimensions but without the actual data.</p><p>The resulting tensor is stored in <code>tn</code> under the symbol <code>C_id</code> if one is provided, otherwise a new id is created for it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQX/QXTn.jl/blob/b421f835400f65583753677d91a33ea7c2e6bb35/src/tensor_network.jl#LL193-L201">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QXTn.contract_tensors-Tuple{QXTensor, QXTensor}" href="#QXTn.contract_tensors-Tuple{QXTensor, QXTensor}"><code>QXTn.contract_tensors</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">contract_tensors(A::QXTensor, B::QXTensor; mock::Bool=false)</code></pre><p>Function to contract two QXTensors and return another QXTensor. If the mock flag is false or either of the input tensors use MockTensor then the storage for the final tensor will be of type MockTensor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQX/QXTn.jl/blob/b421f835400f65583753677d91a33ea7c2e6bb35/src/tensor.jl#LL194-L200">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QXTn.contract_tn!-Tuple{TensorNetwork, Vector{Tuple{Symbol, Symbol, Symbol}}}" href="#QXTn.contract_tn!-Tuple{TensorNetwork, Vector{Tuple{Symbol, Symbol, Symbol}}}"><code>QXTn.contract_tn!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">contract_tn!(tn::TensorNetwork, plan)</code></pre><p>Contract the indices of &#39;tn&#39; according to &#39;plan&#39;.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQX/QXTn.jl/blob/b421f835400f65583753677d91a33ea7c2e6bb35/src/tensor_network.jl#LL227-L231">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QXTn.create_test_tnc-Tuple{}" href="#QXTn.create_test_tnc-Tuple{}"><code>QXTn.create_test_tnc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">create_test_tnc(;input::Union{String, Nothing}=nothing,
                output::Union{String, Nothing}=nothing,
                no_input::Bool=false,
                no_output::Bool=false,
                kwargs...)</code></pre><p>Create a tensor network circuit for a small example circuit, 3 qubit ghz preparation circuit in this case</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQX/QXTn.jl/blob/b421f835400f65583753677d91a33ea7c2e6bb35/src/tensor_network_circuit.jl#LL182-L190">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QXTn.decompose_gate" href="#QXTn.decompose_gate"><code>QXTn.decompose_gate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">function decompose_gate!(gate_data::Array{&lt;:Number, 4},
                         threshold::AbstractFloat=1e-15)</code></pre><p>Function to decompose a tensor into two smaller tensors</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQX/QXTn.jl/blob/b421f835400f65583753677d91a33ea7c2e6bb35/src/utils.jl#LL3-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QXTn.decompose_tensor!-Tuple{TensorNetwork, Symbol, Vector{var&quot;#s21&quot;} where var&quot;#s21&quot;&lt;:Index}" href="#QXTn.decompose_tensor!-Tuple{TensorNetwork, Symbol, Vector{var&quot;#s21&quot;} where var&quot;#s21&quot;&lt;:Index}"><code>QXTn.decompose_tensor!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">decompose_tensor!(tn::TensorNetwork,
                  tensor_id::Symbol,
                  left_indices::Array{&lt;:Index, 1};
                  contract_S_with::Symbol=:V,
                  kwargs...)</code></pre><p>Function to decompose a tensor in a tensor network using svd.</p><p><strong>Keywords</strong></p><ul><li><code>contract_S_with::Symbol=:V</code>: the maxtrix which should absorb the matrix of singular values</li><li><code>maxdim::Int</code>: the maximum number of singular values to keep.</li><li><code>mindim::Int</code>: the minimum number of singular values to keep.</li><li><code>cutoff::Float64</code>: set the desired truncation error of the SVD.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQX/QXTn.jl/blob/b421f835400f65583753677d91a33ea7c2e6bb35/src/tensor_network.jl#LL244-L258">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QXTn.find_hyper_edges-Union{Tuple{AbstractArray{Elt, N}}, Tuple{N}, Tuple{Elt}} where {Elt, N}" href="#QXTn.find_hyper_edges-Union{Tuple{AbstractArray{Elt, N}}, Tuple{N}, Tuple{Elt}} where {Elt, N}"><code>QXTn.find_hyper_edges</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function find_hyper_edges(A::AbstractArray{Elt, N}) where {Elt, N}</code></pre><p>Function to identify hyper edges of tensors. Returns an array of tuples of indices of the original tensor which can be identified</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQX/QXTn.jl/blob/b421f835400f65583753677d91a33ea7c2e6bb35/src/utils.jl#LL35-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QXTn.get_hyperedges-Tuple{TensorNetwork}" href="#QXTn.get_hyperedges-Tuple{TensorNetwork}"><code>QXTn.get_hyperedges</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_hyperedges(tn::TensorNetwork)::Array{Array{Symbol, 1}, 1}</code></pre><p>Return an array of hyperedges in the given tensornetwork <code>tn</code>. </p><p>Hyperedges are represented as arrays of tensor symbols.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQX/QXTn.jl/blob/b421f835400f65583753677d91a33ea7c2e6bb35/src/tensor_network.jl#LL377-L383">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QXTn.hyperindices-Tuple{QXTensor}" href="#QXTn.hyperindices-Tuple{QXTensor}"><code>QXTn.hyperindices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">hyperindices(t::QXTensor)</code></pre><p>Function to get the hyper indices as an array of arrays of Indices</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQX/QXTn.jl/blob/b421f835400f65583753677d91a33ea7c2e6bb35/src/tensor.jl#LL140-L144">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QXTn.isdiagonal-Union{Tuple{AbstractMatrix{Elt}}, Tuple{Elt}} where Elt" href="#QXTn.isdiagonal-Union{Tuple{AbstractMatrix{Elt}}, Tuple{Elt}} where Elt"><code>QXTn.isdiagonal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isdiagonal(A::AbstractArray{Elt, 2}) where Elt</code></pre><p>Function to check if the given matrix is diagonal</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQX/QXTn.jl/blob/b421f835400f65583753677d91a33ea7c2e6bb35/src/utils.jl#LL88-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QXTn.isdiagonal-Union{Tuple{N}, Tuple{Elt}, Tuple{AbstractArray{Elt, N}, Pair{Int64, Int64}}} where {Elt, N}" href="#QXTn.isdiagonal-Union{Tuple{N}, Tuple{Elt}, Tuple{AbstractArray{Elt, N}, Pair{Int64, Int64}}} where {Elt, N}"><code>QXTn.isdiagonal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isdiagonal(A::AbstractArray{Elt, N}, Pair{Int64, Int64}) where {Elt, N}</code></pre><p>Function to check if the given matrix is diagonal along given axes</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQX/QXTn.jl/blob/b421f835400f65583753677d91a33ea7c2e6bb35/src/utils.jl#LL72-L76">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QXTn.mock_contract" href="#QXTn.mock_contract"><code>QXTn.mock_contract</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">mock_contract(T1::NDTensors.Tensor,
              labelsT1,
              T2::NDTensors.Tensor,
              labelsT2,
              labelsR = NDTensors.contract_labels(labelsT1, labelsT2))</code></pre><p>Overloaded contract function from NDTensors which implements contraction for tensors using MockTensor objects as storage.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQX/QXTn.jl/blob/b421f835400f65583753677d91a33ea7c2e6bb35/src/mock_tensor.jl#LL33-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QXTn.neighbours-Tuple{TensorNetwork, Symbol}" href="#QXTn.neighbours-Tuple{TensorNetwork, Symbol}"><code>QXTn.neighbours</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">neighbours(tn::TensorNetwork, tensor::Symbol)</code></pre><p>Function get the symbols of the neighbouring tensors</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQX/QXTn.jl/blob/b421f835400f65583753677d91a33ea7c2e6bb35/src/tensor_network.jl#LL85-L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QXTn.push_input!-Union{Tuple{Elt}, Tuple{TensorNetworkCircuit, Vector{Elt}, Int64}} where Elt" href="#QXTn.push_input!-Union{Tuple{Elt}, Tuple{TensorNetworkCircuit, Vector{Elt}, Int64}} where Elt"><code>QXTn.push_input!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">push_input!(tnc::TensorNetworkCircuit, tensor::Array{Elt, 1}, pos::Int64) where Elt</code></pre><p>Function to add a single input tensor to the tensor network circuit at the given position</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQX/QXTn.jl/blob/b421f835400f65583753677d91a33ea7c2e6bb35/src/tensor_network_circuit.jl#LL124-L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QXTn.push_output!-Union{Tuple{Elt}, Tuple{TensorNetworkCircuit, Vector{Elt}, Int64}} where Elt" href="#QXTn.push_output!-Union{Tuple{Elt}, Tuple{TensorNetworkCircuit, Vector{Elt}, Int64}} where Elt"><code>QXTn.push_output!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">push_output!(tnc::TensorNetworkCircuit, tensor::Array{Elt, 1}, pos::Int64) where Elt</code></pre><p>Function to add a single output tensor to the tensor network circuit at the given position</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQX/QXTn.jl/blob/b421f835400f65583753677d91a33ea7c2e6bb35/src/tensor_network_circuit.jl#LL138-L142">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QXTn.reduce_tensor-Union{Tuple{N}, Tuple{Elt}, Tuple{AbstractArray{Elt, N}, Vector{Vector{Int64}}}} where {Elt, N}" href="#QXTn.reduce_tensor-Union{Tuple{N}, Tuple{Elt}, Tuple{AbstractArray{Elt, N}, Vector{Vector{Int64}}}} where {Elt, N}"><code>QXTn.reduce_tensor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">reduce_tensor(A::AbstractArray{Elt, N}, hyper_index_groups::Array{Int64, 1})</code></pre><p>Function to reduce the dimension of the given tensor assuming the given hyper edge groups. For example a diagonal matrix will have a single hyper edge group with both indices [1, 2]</p><pre><code class="language-julia-repl">julia&gt; QXTn.reduce_tensor([[1, 0] [0, 2]], [[1, 2]])
2-element Vector{Int64}:
 1
 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQX/QXTn.jl/blob/b421f835400f65583753677d91a33ea7c2e6bb35/src/utils.jl#LL101-L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QXTn.replace_tensor_symbol!-Tuple{TensorNetwork, Symbol, Symbol}" href="#QXTn.replace_tensor_symbol!-Tuple{TensorNetwork, Symbol, Symbol}"><code>QXTn.replace_tensor_symbol!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">replace_tensor_symbol!(tn::TensorNetwork, orig_sym::Symbol, new_sym::Symbol)</code></pre><p>Replace the given symbol with the given new symbol</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQX/QXTn.jl/blob/b421f835400f65583753677d91a33ea7c2e6bb35/src/tensor_network.jl#LL362-L366">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QXTn.replace_with_svd!-Tuple{TensorNetwork, Symbol, Vector{var&quot;#s21&quot;} where var&quot;#s21&quot;&lt;:Index}" href="#QXTn.replace_with_svd!-Tuple{TensorNetwork, Symbol, Vector{var&quot;#s21&quot;} where var&quot;#s21&quot;&lt;:Index}"><code>QXTn.replace_with_svd!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">replace_with_svd!(tn::TensorNetwork, 
                  tensor_id::Symbol,
                  left_indices::Array{&lt;:Index, 1};
                  kwargs...)</code></pre><p>Function to replace a tensor in a tensor network with its svd.</p><p>The indices contained in &#39;left_indices&#39; are considered the row indices of the tensor when the svd is performed.</p><p><strong>Keywords</strong></p><ul><li><code>maxdim::Int</code>: the maximum number of singular values to keep.</li><li><code>mindim::Int</code>: the minimum number of singular values to keep.</li><li><code>cutoff::Float64</code>: set the desired truncation error of the SVD.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQX/QXTn.jl/blob/b421f835400f65583753677d91a33ea7c2e6bb35/src/tensor_network.jl#LL276-L291">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QXTn.simple_contraction!-Tuple{TensorNetwork}" href="#QXTn.simple_contraction!-Tuple{TensorNetwork}"><code>QXTn.simple_contraction!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">simple_contraction!(tn::TensorNetwork)</code></pre><p>Function to perfrom a simple contraction, contracting all tensors in order. Only useful for very small networks for testing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQX/QXTn.jl/blob/b421f835400f65583753677d91a33ea7c2e6bb35/src/tensor_network.jl#LL178-L183">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QXTn.simple_contraction-Tuple{TensorNetwork}" href="#QXTn.simple_contraction-Tuple{TensorNetwork}"><code>QXTn.simple_contraction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">simple_contraction(tn::TensorNetwork)</code></pre><p>Function to perfrom a simple contraction, contracting all tensors in order. Only useful for very small networks for testing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQX/QXTn.jl/blob/b421f835400f65583753677d91a33ea7c2e6bb35/src/tensor_network.jl#LL168-L173">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QXTn.tensor_data-Tuple{QXTensor}" href="#QXTn.tensor_data-Tuple{QXTensor}"><code>QXTn.tensor_data</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">tensor_data(tensor::QXTensor; consider_hyperindices::Bool=false)</code></pre><p>Get the data associated with the given tensor. If the consider_hyperindices flag is true then only the first of the hyper indices are retained. For example for a 5 rank tensor where the 2nd and 4th indices form a group of hyper indices, with this option set to true would return a rank 4 tensor where the 2nd index</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaQX/QXTn.jl/blob/b421f835400f65583753677d91a33ea7c2e6bb35/src/tensor.jl#LL115-L122">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="data_structures/">Data Structures »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 29 March 2021 11:58">Monday 29 March 2021</span>. Using Julia version 1.6.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
